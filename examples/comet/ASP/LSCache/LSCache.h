//
// Generated by tlb2h for Comet 1 gamma 33 (20060626)
//

#ifndef COMET_TYPELIB_LSCache_INCLUDED
#define COMET_TYPELIB_LSCache_INCLUDED

#pragma pack(push, 8)

#include <comet/config.h>
#if COMET_BUILD != 20060626
#error This header was generated with a different version of tlb2h. Please rebuild
#endif

#include <comet/assert.h>
#include <comet/ptr.h>
#include <comet/util.h>
#include <comet/uuid.h>
#include <comet/common.h>
#include <comet/bstr.h>
#include <comet/tstring.h>
#include <comet/variant.h>

#include <comet/server.h>

namespace comet {

namespace LSCache {

// VC workaround. (sigh!)
struct DECLSPEC_UUID("A8A534D3-B4C9-46D3-9355-D1828CB4415E") LSCache_type_library;
typedef LSCache_type_library type_library;

//
// Forward references and typedefs
//

struct DECLSPEC_UUID("D1855C2E-2275-4B80-9657-E1E6E26AFB64") ICache;

//
// Interface typedefs
//

typedef com_ptr<ICache> ICachePtr;

//
// Impl Wrappers (forward declaration)
//

template<typename _B, typename _S = ICache, typename _TL = LSCache_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("D1855C2E-2275-4B80-9657-E1E6E26AFB64") ICacheImpl;

//
// Coclass definitions
//

struct DECLSPEC_UUID("1E5B58C4-3C6E-462B-9DC4-3DB169952B45") Cache {
    typedef  make_list<ICache>::result  interfaces;
    typedef  make_list<>::result  source_interfaces;
    typedef  make_list<ICacheImpl< coclass_implementation<Cache> , ICache, LSCache_type_library > >::result interface_impls;
    typedef LSCache_type_library type_library;
    static const TCHAR* name() { return _T("Cache"); }
    enum { major_version = 0, minor_version = 0 };
    static com_ptr<ICache> create() {return com_ptr<ICache>(uuidof<Cache>()); };
};


struct LSCache_type_library {
    enum { major_version = 1, minor_version = 0 };
    typedef  make_list<Cache>::result  coclasses;
};

} // namespace

//
// Named GUIDs
//

template<> struct comtype<LSCache::LSCache_type_library> {
    static const IID& uuid()
    { static const GUID iid = { 0xA8A534D3, 0xB4C9, 0x46D3, { 0x93, 0x55, 0xD1, 0x82, 0x8C, 0xB4, 0x41, 0x5E } }; return iid; }
    typedef nil base;
};

template<> struct comtype<LSCache::Cache> {
    static const IID& uuid()
    { static const GUID iid = { 0x1E5B58C4, 0x3C6E, 0x462B, { 0x9D, 0xC4, 0x3D, 0xB1, 0x69, 0x95, 0x2B, 0x45 } }; return iid; }
    typedef nil base;
};

template<> struct comtype<LSCache::ICache> {
    static const IID& uuid()
    { static const GUID iid = { 0xD1855C2E, 0x2275, 0x4B80, { 0x96, 0x57, 0xE1, 0xE6, 0xE2, 0x6A, 0xFB, 0x64 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef LSCache::ICacheImpl<B> normal;
    };
};


//
// Enum sa_trait declarations
//

namespace impl {
    template<> struct sa_traits< com_ptr<LSCache::ICache> > : public interface_sa_traits<LSCache::ICache, VT_DISPATCH, FADF_DISPATCH> {};
} // namespace



namespace LSCache {

//
// Interface declarations
//

struct DECLSPEC_UUID("D1855C2E-2275-4B80-9657-E1E6E26AFB64") ICache : public ::IDispatch {

    // Raw methods
    virtual STDMETHODIMP get_Value(BSTR par_idx, BSTR par_key, VARIANT* par_pVal) = 0;
    virtual STDMETHODIMP put_Value(BSTR par_idx, BSTR par_key, VARIANT par_pVal) = 0;
    virtual STDMETHODIMP raw_EnumerateKeys(::IEnumVARIANT** par_pVal) = 0;
    virtual STDMETHODIMP get_Count(long* par_pVal) = 0;
    virtual STDMETHODIMP put_Expiry(long par_pv) = 0;
    virtual STDMETHODIMP get_Expiry(long* par_pv) = 0;
    virtual STDMETHODIMP put_MaxSize(long par_pv) = 0;
    virtual STDMETHODIMP get_MaxSize(long* par_pv) = 0;
    virtual STDMETHODIMP raw_Remove(BSTR par___MIDL_0010) = 0;
};

} // namespace

//
// Interface wrapper declarations
//

template<> struct wrap_t<LSCache::ICache> {

    // Wrapper declarations
    inline variant_t GetValue(const bstr_t& par_idx, const bstr_t& par_key);
    inline void PutValue(const bstr_t& par_idx, const bstr_t& par_key, const variant_t& par_pVal);
    inline com_ptr<::IEnumVARIANT> EnumerateKeys();
    inline long GetCount();
    inline void PutExpiry(long par_pv);
    inline long GetExpiry();
    inline void PutMaxSize(long par_pv);
    inline long GetMaxSize();
    inline void Remove(const bstr_t& par___MIDL_0010);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetCount))
    long Count;
    __declspec(property(put=PutExpiry, get=GetExpiry))
    long Expiry;
    __declspec(property(put=PutMaxSize, get=GetMaxSize))
    long MaxSize;
    __declspec(property(put=PutValue, get=GetValue))
    variant_t Value[][];
#endif
};

//
// Method wrappers
//

inline variant_t wrap_t<LSCache::ICache>::GetValue(const bstr_t& par_idx, const bstr_t& par_key)
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->get_Value(par_idx.in(), par_key.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<LSCache::ICache>::PutValue(const bstr_t& par_idx, const bstr_t& par_key, const variant_t& par_pVal)
{
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->put_Value(par_idx.in(), par_key.in(), par_pVal.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
}

inline com_ptr<::IEnumVARIANT> wrap_t<LSCache::ICache>::EnumerateKeys()
{
    ::IEnumVARIANT* _result_;
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->raw_EnumerateKeys(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
    return auto_attach(_result_);
}

inline long wrap_t<LSCache::ICache>::GetCount()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->get_Count(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
    return _result_;
}

inline void wrap_t<LSCache::ICache>::PutExpiry(long par_pv)
{
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->put_Expiry(par_pv);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
}

inline long wrap_t<LSCache::ICache>::GetExpiry()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->get_Expiry(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
    return _result_;
}

inline void wrap_t<LSCache::ICache>::PutMaxSize(long par_pv)
{
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->put_MaxSize(par_pv);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
}

inline long wrap_t<LSCache::ICache>::GetMaxSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->get_MaxSize(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
    return _result_;
}

inline void wrap_t<LSCache::ICache>::Remove(const bstr_t& par___MIDL_0010)
{
    HRESULT _hr_ = reinterpret_cast<LSCache::ICache*>(this)->raw_Remove(par___MIDL_0010.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<LSCache::ICache*>(this), _hr_);
}


namespace LSCache {

//
// Impl Wrappers (declaration)
//

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("D1855C2E-2275-4B80-9657-E1E6E26AFB64") ICacheImpl : public impl_dispatch<_S, _TL>
{
    typedef ICache interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Value(BSTR par_idx, BSTR par_key, VARIANT* par_pVal);
    STDMETHODIMP put_Value(BSTR par_idx, BSTR par_key, VARIANT par_pVal);
    STDMETHODIMP raw_EnumerateKeys(::IEnumVARIANT** par_pVal);
    STDMETHODIMP get_Count(long* par_pVal);
    STDMETHODIMP put_Expiry(long par_pv);
    STDMETHODIMP get_Expiry(long* par_pv);
    STDMETHODIMP put_MaxSize(long par_pv);
    STDMETHODIMP get_MaxSize(long* par_pv);
    STDMETHODIMP raw_Remove(BSTR par___MIDL_0010);

    //
    // These are the methods you need to implement: 
    //
/*
    variant_t GetValue(const bstr_t& par_idx, const bstr_t& par_key);
    void PutValue(const bstr_t& par_idx, const bstr_t& par_key, const variant_t& par_pVal);
    com_ptr<::IEnumVARIANT> EnumerateKeys();
    long GetCount();
    void PutExpiry(long par_pv);
    long GetExpiry();
    void PutMaxSize(long par_pv);
    long GetMaxSize();
    void Remove(const bstr_t& par___MIDL_0010);
*/
};

//
// Impl Wrappers (implementation)
//

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::get_Value(BSTR par_idx, BSTR par_key, VARIANT* par_pVal)
{
    COMET_ASSERT(par_pVal);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pVal) return E_POINTER;
#endif
    ::VariantInit(par_pVal);
    try {
        /*
          variant_t GetValue(const bstr_t& par_idx, const bstr_t& par_key);
        */
        *par_pVal = variant_t::detach(static_cast<_B*>(this)->GetValue(bstr_t::create_const_reference(par_idx), bstr_t::create_const_reference(par_key)));
    } COMET_CATCH_CLASS(L"GetValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::put_Value(BSTR par_idx, BSTR par_key, VARIANT par_pVal)
{
    try {
        /*
          void PutValue(const bstr_t& par_idx, const bstr_t& par_key, const variant_t& par_pVal);
        */
        static_cast<_B*>(this)->PutValue(bstr_t::create_const_reference(par_idx), bstr_t::create_const_reference(par_key), variant_t::create_const_reference(par_pVal));
    } COMET_CATCH_CLASS(L"PutValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::raw_EnumerateKeys(::IEnumVARIANT** par_pVal)
{
    COMET_ASSERT(par_pVal);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pVal) return E_POINTER;
#endif
    try {
        /*
          com_ptr<::IEnumVARIANT> EnumerateKeys();
        */
        *par_pVal = com_ptr<::IEnumVARIANT>::detach(static_cast<_B*>(this)->EnumerateKeys());
    } COMET_CATCH_CLASS(L"EnumerateKeys");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::get_Count(long* par_pVal)
{
    COMET_ASSERT(par_pVal);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pVal) return E_POINTER;
#endif
    try {
        /*
          long GetCount();
        */
        *par_pVal = static_cast<_B*>(this)->GetCount();
    } COMET_CATCH_CLASS(L"GetCount");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::put_Expiry(long par_pv)
{
    try {
        /*
          void PutExpiry(long par_pv);
        */
        static_cast<_B*>(this)->PutExpiry(par_pv);
    } COMET_CATCH_CLASS(L"PutExpiry");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::get_Expiry(long* par_pv)
{
    COMET_ASSERT(par_pv);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pv) return E_POINTER;
#endif
    try {
        /*
          long GetExpiry();
        */
        *par_pv = static_cast<_B*>(this)->GetExpiry();
    } COMET_CATCH_CLASS(L"GetExpiry");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::put_MaxSize(long par_pv)
{
    try {
        /*
          void PutMaxSize(long par_pv);
        */
        static_cast<_B*>(this)->PutMaxSize(par_pv);
    } COMET_CATCH_CLASS(L"PutMaxSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::get_MaxSize(long* par_pv)
{
    COMET_ASSERT(par_pv);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pv) return E_POINTER;
#endif
    try {
        /*
          long GetMaxSize();
        */
        *par_pv = static_cast<_B*>(this)->GetMaxSize();
    } COMET_CATCH_CLASS(L"GetMaxSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ICacheImpl<_B, _S, _TL>::raw_Remove(BSTR par___MIDL_0010)
{
    try {
        /*
          void Remove(const bstr_t& par___MIDL_0010);
        */
        static_cast<_B*>(this)->Remove(bstr_t::create_const_reference(par___MIDL_0010));
    } COMET_CATCH_CLASS(L"Remove");
    return S_OK;
}

} // end of namespace

} // end of namespace

#pragma pack(pop)
#endif
